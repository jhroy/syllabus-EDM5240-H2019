# coding: utf-8

### POUR LIRE DES API EN DIRECT SUR LE WEB

### MAIS D'ABORD -> QU'EST-CE QU'UN API?
# C'EST UNE INTERFACE DE PROGRAMMATON (APPLICATION PROGRAMMING INTERFACE EN ANGLAIS)
# LA PLUPART DES OUTILS QUE VOUS UTILISEZ QUOTIDIENNEMENT (FACEBOOK, INSTA, TWITCH, ETC.)
# SONT EN FAIT D'IMMENSES BASES DE DONNÉES
# LEUR PAGE WEB OU APPLICATIONS MOBILES SONT DES INTERFACES POUR LES HUMAINS
# PLUSIEURS DE CES SERVICES ONT AUSSI UNE INTERFACE POUR LES ORDINATEURS: C'EST LEUR API

# IL FAUT D'ABORD IMPORTER DES MODULES COMPLÉMENTAIRES

# JSON POUR TRAITER DES FICHIERS DE DONNÉES «.json», LE FORMAT LE PLUS COURAMMENT UTILISÉ PAR LES API
import json

# ON IMPORTE AUSSI CSV CAR ON VA, AU FINAL, CRÉER UN FICHIER CSV
import csv

# ON IMPORTE UN MODULE POUR INTERAGIR AVEC UN SERVEUR WEB
# COMME ON FAIT DES REQUÊTES SUR LE WEB, CE MODULE S'APPELLE «requests»
import requests

# ON DÉTERMINE TOUT DE SUITE LE NOM QU'AURA NOTRE FICHIER CSV ET ON PLACE CE NOM DANS UNE VARIABLE
fichier = "tremblementsDeTerre.csv"

# VOICI L'URL QU'ON VA CONSULTER
# VOUS POUVEZ LA COPIER-COLLER DANS UN NAVIGATEUR (FIREFOX, CHROME, ETC)
# C'EST UN FICHIER JSON DE TOUS LES TREMBLEMENTS DE TERRE ENREGISTRÉS AU CANADA
# AU COURS DES 7 DERNIERS JOURS
url = "http://www.earthquakescanada.nrcan.gc.ca/api/v2/locations/latest/7d.json"

# ÉTHIQUE APPLIQUÉE AU MOISSONNAGE DE DONNÉES
# ON FAIT DU JOURNALISME À VISIÈRE LEVÉE
# IL EST DONC SOUHAITABLE DE S'IDENTIFIER QUAND ON COGNE À LA PORTE D'UN SERVEUR
entete = {
	"User-Agent":"Jean-Hugues Roy - 514/778-6102",
	"From":"roy.jean-hugues@uqam.ca"
}

# ON UTILISE LA MÉTHODE «.get» DU MODULE REQUESTS AVEC DEUX PARAMÈTRES:
# L'URL DONT ON FAIT LA REQUÊTE
# ET LES ENTÊTES QUI ACCOMPAGNENT NOTRE REQUÊTE
# ON PLACE LE RÉSULTAT DANS UNE VARIABLE TEMPORAIRE QU'ON PEUT APPELER «req»
req = requests.get(url,headers=entete)

# ON PEUT VÉRIFIER CE QU'ELLE CONTIENT
print(req)

# ON VOIT LE STATUT DE NOTRE REQUÊTE
# 200 SIGNIFIE QUE ÇA FONCTIONNE
# 404 SIGNIFIE QUE LE CONTENU N'EST PAS DISPONIBLE
# 500 SIGNIFIE UNE ERREUR DU SERVEUR

# ON PEUT DONC FAIRE UN TEST POUR VOIR SI NOTRE REQUÊTE FONTIONNE
# SI LE STATUT N'EST PAS 200, C'EST QUE ÇA NE MARCHE PAS
if req.status_code != 200:
	print("Ça marche pas")

# SINON, C'EST QUE LE STATUT EST 200, ALORS ON PEUT EXTRAIRE LES DONNÉES DE L'API
else:

	# ON COMMENCE PAR TRAITER LE CONTENU DE NOTRE VARIABLE «REQ» AVEC LE MODULE JSON
	# ET ON LE PLACE DANS UN VARIABLE
	terre = req.json()

	# ON PEUT VÉRIFIER CE QUE NOTRE VARIABLE CONTIENT. C'EST DU CHARABIA.
	print(terre)

	# EN FAIT, CET API EST UN DICTIONNAIRE QUI CONTIENT PLUSIEURS DICTIONNAIRES
	# CHACUN DE CES DICTIONNAIRES DÉCRIT UN SÉISME

	for seisme in terre:
		print(seisme)
		# ICI, ON CONTATE QU'ON N'A PAS BEAUCOUP D'INFORMATION
		# LA VARIABLE SÉISME NE CONTIENT QUE LES CLÉS DES DICTIONNAIRES
		# CE QUI NOUS INTÉRESSE, CE SONT LES VALEURS

		# ON VA DONC MODIFIER NOTRE BOUCLE AINSI:
	for seisme in terre.values():

		# LES VALEURS DE CHAQUE DICTIONNAIRE SONT AFFICHÉES
		print(seisme)

		# POUR RENDRE L'AFFICHAGE PLUS LISIBLE, ON VA SÉPARER CHAQUE SÉISME PAR UNE PETITE LIGNE
		print("~"*80)

		# DANS LE CAS DE CET API, LE PREMIER DICTIONNAIRE CONTIENT QUELQUES MÉTADONNÉES QUI NE NOUS INTÉRESSENT PAS
		# ON VA L'ESCAMOTER AVEC CETTE CONDITION (SI LE DICTIONNAIRE NE CONTIENT PAS LE MOT «MAGNITUDE», ON NE L'EXAMINERA PAS)
		if "magnitude" in seisme:

			# EN EXAMINANT ATTENTIVEMENT LES DONNÉES JSON, ON PEUT DÉTERMINER COMMENT LES RÉCUPÉRER
			# LA MAGNITUDE SE TROUVE DANS UNE PAIRE DE CLÉ/VALEUR COMME CELLE-CI:
			# {"magnitude":3.5}
			# CE QUI NOUS INTÉRESSE, C'EST LA VALEUR
			# ON Y ACCÈDE EN UTILISANT LA CLÉ COMME ON UTILISE L'INDEX DANS UNE LISTE
			print(seisme["magnitude"])

			# PARMI LES INFORMATIONS POUVANT NOUS INTÉRESSER DANS L'API SE TROUVE LA DESCRIPTION DU SÉISME
			# ELLE EST CONTENUE DANS UNE PAIRE DE CLÉ/VALEUR COMME CELLE-CI:
			# {"location":{"fr":"53 km S-E de Moisie, QC ZONE SISMIQUE DU BAS-SAINT-LAURENT, QC."}}
			# LA VALEUR DE LA CLÉ «LOCATION» EST UN AUTRE DICTIONNAIRE NE CONTENANT QU'UNE SEULE PAIRE CLÉ/VALEUR:
			# {"fr":"53 km S-E de Moisie, QC ZONE SISMIQUE DU BAS-SAINT-LAURENT, QC."}
			# C'EST LA VALEUR DE CET AUTRE DICTIONNAIRE QUI NOUS INTÉRESSE; ON L'AFFICHER EN DEMANDANT SA CLÉ («FR»).
			# LA REQUÊTE POUR Y PARVENIR EST AINSI:
			print(seisme["location"]["fr"])

			# POUR TROUVER LES COORDONNÉES DU SÉISME, IL FAUT FOUILLER ENCORE PLUS PROFONDÉMENT DANS LE JSON RETOURNÉ PAR L'API
			# LES COORDONNÉES SE TROUVENT DANS UNE PAIRE DE CLÉ/VALEUR COMME CELLE-CI:
			# {"geoJSON":{"type":"Point","coordinates":[55.368,-121.855]}}
			# LA VALEUR DE LA CLÉ «GEOJSON» EST UN AUTRE DICTIONNAIRE CONTENANT, LUI, DEUX PAIRES DE CLÉ/VALEUR:
			# {"type":"Point","coordinates":[55.368,-121.855]}
			# C'EST LA DEUXIÈME QUI NOUS INTÉRESSE:
			# "coordinates":[55.368,-121.855]
			# ICI, LA VALEUR DE LA CLÉ «COORDINATES» EST DIFFÉRENTE. C'EST UNE LISTE:
			# [55.368,-121.855]
			# LA LATITUDE EST LE PREMIER ÉLÉMENT DE CETTE LISTE. POUR L'AFFICHER, ON ENTRE DONC:
			print(seisme["geoJSON"]["coordinates"][0])

			# LA LONGITUDE EST LE 2E ÉLÉMENT DE CETTE LISTE. POUR L'AFFICHER, ON ENTRE DONC:
			print(seisme["geoJSON"]["coordinates"][1])

			# AFIN DE CONSIGNER CES INFORMATION DANS UN FICHIER CSV, ON DOIT D'ABORD LES METTRE DANS UNE LISTE
			# ON SE CRÉE DONC UNE LISTE QUI, POUR LE MOMENT, EST VIDE. ON LUI DONNE LE NOM QU'ON VEUT.
			s = []

			# AU MOYEN DE LA MÉTHODE «.append()», ON AJOUTE À CETTE LISTE TOUTES LES INFORMATIONS QUI NOUS INTÉRESSENT DANS LE JSON
			# ON LES RÉCUPÈRE DE LA MÊME FAÇON QU'ON LES A AFFICHÉES PLUS HAUT.
			s.append(seisme["magnitude"])
			s.append(seisme["location"]["fr"])
			s.append(seisme["geoJSON"]["coordinates"][0])
			s.append(seisme["geoJSON"]["coordinates"][1])

			# POUR VÉRIFIER SI TOUT VA BIEN, ON PEUT AFFICHER LE CONTENU DE NOTRE LISTE
			print(s)
			print("~"*80)

			# TOUT VA BIEN. ON PEUT AJOUTER LE CONTENU DE CETTE LISTE AU CSV DONT ON A DÉFINI LE NOM AU DÉBUT DU SCRIPT
			# ON COMMENCE PAR SE CRÉER UNE 1RE VARIABLE TEMPORAIRE QUI OUVRE NOTRE FICHIER AVEC LA FONCTION «OPEN»
			# IL Y A 2 PARAMÈTRES DANS CETTE FONCTION: LE NOM DU FICHIER, D'ABORD, PUIS LE MODE.
			# ICI, «a», SIGNIFIE QU'ON ÉCRIT DANS NOTRE FICHIER EN MODE «APPEND»
			# C'EST-À-DIRE QUE LA LIGNE QU'ON AJOUTE VA S'ADJOINDRE AU CONTENU DÉJÀ EXISTANT
			# PAR DÉFAUT, LE MODE EST «w» ET CELA EFFACE TOUT LE CONTENU QUI EST DÉJÀ DANS NOTRE FICHIER. ON NE VEUT PAS CELA.
			henri = open(fichier,"a")

			# ON UTILISE ENSUITE LA MÉTHODE «.writer()» DU MODULE CSV POUR SE CRÉER UNE 2E VARIABLE TEMPORAIRE À PARTIR DE NOTRE PREMIÈRE.
			# LE POURQUOI 
			bourassa = csv.writer(henri)
			bourassa.writerow(s)

			# VOICI ENFIN LA RECETTE POUR CONSIGNER LE CONTENU DE NOTRE LISTE DANS UNE NOUVELLE LIGNE
			# DU FICHIER CSV DONT ON A DÉFINI LE NOM AU DÉBUT DE NOTRE SCRIPT
			# IL N'EST PAS NÉCESSAIRE DE COMPRENDRE LA MÉCANIQUE COMPLÈTE DE CE QUE FONT LES TROIS COMMANDES CI-DESSOUS
			# VOUS POUVEZ DONNER AUX VARIABLES LES NOMS QUE VOUS VOULEZ (J'AI MIS LE NOM D'UN GROUPE DE POÈTES CONTEMPORAINS)
			dead = open(fichier,"a") 
			obies = csv.writer(dead)
			obies.writerow(s)
			# DEUX CHOSES IMPORTANTES À RETENIR:
			# -> LA FONCTION OPEN DOIT PRENDRE LE PARAMÈTRE «a»
			# ÇA, C'EST LE MODE D'ÉCRITURE QUE VOUS DÉFINISSEZ
			# «A» SIGNIFIE «APPEND», CE QUI VEUT DIRE QUE QUE LA LIGNE QU'ON AJOUTE VA S'ADJOINDRE AU CONTENU DÉJÀ EXISTANT
			# PAR DÉFAUT, LE MODE EST «w» ET CELA EFFACE TOUT LE CONTENU QUI EST DÉJÀ DANS NOTRE FICHIER. ON NE VEUT PAS CELA.
			# -> 2E CHOSE, À LA DERNIÈRE LIGNE, LE PARAMÈTRE DE LA MÉTHODE «writerow» EST LE NOM DE LA LISTE QUI CONTIENT LES INFORMATIONS/DONNÉES QU'ON A UTILISÉE PLUS HAUT